<!DOCTYPE html>
<html>
<head>
    <title>WebCraft</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial;
        }
    </style>
</head>
<body>
    <div id="info">WASD - Движение | ЛКМ - Ломать блок | ПКМ - Ставить блок | 1-3 - Выбор блока</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/perlin.js/1.0.0/perlin.js"></script>

<script>
let scene, camera, renderer, controls;
let world = {};
let selectedBlock = 1;
const BLOCK_TYPES = {
    1: { color: 0x00ff00, name: 'Трава' },
    2: { color: 0x804000, name: 'Земля' },
    3: { color: 0x808080, name: 'Камень' }
};

init();
generateWorld();
animate();

function init() {
    // Сцена
    scene = new THREE.Scene();
    
    // Камера
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 15, 0);
    
    // Рендерер
    renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    
    // Освещение
    const light = new THREE.PointLight(0xffffff, 1, 100);
    light.position.set(0, 20, 0);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0x404040));
    
    // Управление
    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('mousedown', onMouseDown);
    document.addEventListener('mousemove', updateCameraRotation);
}

function generateWorld(size = 32) {
    const noise = new PerlinNoise('seed');
    
    for(let x = -size; x < size; x++) {
        for(let z = -size; z < size; z++) {
            const height = Math.floor(noise.get(x/10, z/10) * 8) + 8;
            
            for(let y = 0; y < height; y++) {
                const blockType = y === height-1 ? 1 : y > height-4 ? 2 : 3;
                addBlock(x, y, z, blockType);
            }
        }
    }
}

function addBlock(x, y, z, type) {
    const geometry = new THREE.BoxGeometry(1, 1, 1);
    const material = new THREE.MeshPhongMaterial({ color: BLOCK_TYPES[type].color });
    const cube = new THREE.Mesh(geometry, material);
    cube.position.set(x, y, z);
    scene.add(cube);
    world[`${x},${y},${z}`] = cube;
}

function removeBlock(x, y, z) {
    const key = `${x},${y},${z}`;
    if(world[key]) {
        scene.remove(world[key]);
        delete world[key];
    }
}

function onKeyDown(e) {
    // Движение
    const speed = 0.2;
    const angle = camera.rotation.y;
    
    if(e.key === 'w') {
        camera.position.x -= Math.sin(angle) * speed;
        camera.position.z -= Math.cos(angle) * speed;
    }
    if(e.key === 's') {
        camera.position.x += Math.sin(angle) * speed;
        camera.position.z += Math.cos(angle) * speed;
    }
    if(e.key === 'a') {
        camera.position.x -= Math.cos(angle) * speed;
        camera.position.z += Math.sin(angle) * speed;
    }
    if(e.key === 'd') {
        camera.position.x += Math.cos(angle) * speed;
        camera.position.z -= Math.sin(angle) * speed;
    }
    
    // Выбор блока
    if(e.key >= 1 && e.key <= 3) selectedBlock = parseInt(e.key);
}

function onMouseDown(e) {
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    
    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
    
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(Object.values(world));
    
    if(intersects.length > 0) {
        const intersect = intersects[0];
        const pos = intersect.object.position;
        
        if(e.button === 0) { // ЛКМ - удалить
            removeBlock(pos.x, pos.y, pos.z);
        }
        else if(e.button === 2) { // ПКМ - поставить
            const normal = intersect.face.normal;
            const newPos = pos.clone().add(normal);
            addBlock(newPos.x, newPos.y, newPos.z, selectedBlock);
        }
    }
}

function updateCameraRotation(e) {
    const sensitivity = 0.002;
    camera.rotation.y -= e.movementX * sensitivity;
    camera.rotation.x -= e.movementY * sensitivity;
    camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
}

function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
    
    // Простая гравитация
    const y = Math.floor(camera.position.y);
    if(!world[`${Math.floor(camera.position.x)},${y-1},${Math.floor(camera.position.z)}`]) {
        camera.position.y -= 0.1;
    }
}
</script>
</body>
</html>
